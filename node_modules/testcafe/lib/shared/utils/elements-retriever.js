"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const node_type_descriptions_1 = __importDefault(require("../utils/node-type-descriptions"));
const errors_1 = require("../../shared/errors");
const selector_error_ctor_callback_1 = require("../errors/selector-error-ctor-callback");
// @ts-ignore
const hammerhead_1 = require("../../client/driver/deps/hammerhead");
// @ts-ignore
const testcafe_core_1 = require("../../client/driver/deps/testcafe-core");
class ElementsRetriever {
    constructor(globalSelectorTimeout, executeSelectorFn) {
        this._globalSelectorTimeout = globalSelectorTimeout;
        this._ensureElementsStartTime = hammerhead_1.nativeMethods.dateNow();
        this._ensureElementsPromise = hammerhead_1.Promise.resolve();
        this._executeSelectorFn = executeSelectorFn;
        this._elements = [];
    }
    push(selector, elementName) {
        this._ensureElementsPromise = this._ensureElementsPromise
            .then(() => {
            return this._executeSelectorFn(selector, {
                invisible: selector_error_ctor_callback_1.getInvisibleErrorCtor(elementName),
                notFound: selector_error_ctor_callback_1.getNotFoundErrorCtor(elementName),
            }, this._ensureElementsStartTime);
        })
            .then((el) => {
            if (!testcafe_core_1.domUtils.isDomElement(el)) {
                const nodeType = el.nodeType;
                const nodeTypeStr = node_type_descriptions_1.default[nodeType];
                if (!elementName)
                    throw new errors_1.ActionSelectorMatchesWrongNodeTypeError(nodeTypeStr);
                else
                    throw new errors_1.ActionAdditionalSelectorMatchesWrongNodeTypeError(elementName, nodeTypeStr);
            }
            this._elements.push(el);
        });
    }
    getElements() {
        return this._ensureElementsPromise.then(() => this._elements);
    }
}
exports.default = ElementsRetriever;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWxlbWVudHMtcmV0cmlldmVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL3NoYXJlZC91dGlscy9lbGVtZW50cy1yZXRyaWV2ZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFFQSw2RkFBcUU7QUFDckUsZ0RBRzZCO0FBQzdCLHlGQUFxRztBQUNyRyxhQUFhO0FBQ2Isb0VBQTZFO0FBQzdFLGFBQWE7QUFDYiwwRUFBa0U7QUFFbEUsTUFBcUIsaUJBQWlCO0lBT2xDLFlBQW9CLHFCQUE2QixFQUFFLGlCQUF1QztRQUN0RixJQUFJLENBQUMsc0JBQXNCLEdBQUsscUJBQXFCLENBQUM7UUFDdEQsSUFBSSxDQUFDLHdCQUF3QixHQUFHLDBCQUFhLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDeEQsSUFBSSxDQUFDLHNCQUFzQixHQUFLLG9CQUFPLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDbEQsSUFBSSxDQUFDLGtCQUFrQixHQUFTLGlCQUFpQixDQUFDO1FBQ2xELElBQUksQ0FBQyxTQUFTLEdBQWtCLEVBQUUsQ0FBQztJQUN2QyxDQUFDO0lBRU0sSUFBSSxDQUFFLFFBQWdDLEVBQUUsV0FBb0I7UUFDL0QsSUFBSSxDQUFDLHNCQUFzQixHQUFHLElBQUksQ0FBQyxzQkFBc0I7YUFDcEQsSUFBSSxDQUFDLEdBQUcsRUFBRTtZQUNQLE9BQU8sSUFBSSxDQUFDLGtCQUFrQixDQUFDLFFBQVEsRUFBRTtnQkFDckMsU0FBUyxFQUFFLG9EQUFxQixDQUFDLFdBQVcsQ0FBQztnQkFDN0MsUUFBUSxFQUFHLG1EQUFvQixDQUFDLFdBQVcsQ0FBQzthQUMvQyxFQUFFLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDO1FBQ3RDLENBQUMsQ0FBQzthQUNELElBQUksQ0FBQyxDQUFDLEVBQUssRUFBRSxFQUFFO1lBQ1osSUFBSSxDQUFDLHdCQUFRLENBQUMsWUFBWSxDQUFDLEVBQUUsQ0FBQyxFQUFFO2dCQUM1QixNQUFNLFFBQVEsR0FBTyxFQUFzQyxDQUFDLFFBQVEsQ0FBQztnQkFDckUsTUFBTSxXQUFXLEdBQUcsZ0NBQXNCLENBQUMsUUFBUSxDQUFDLENBQUM7Z0JBRXJELElBQUksQ0FBQyxXQUFXO29CQUNaLE1BQU0sSUFBSSxnREFBdUMsQ0FBQyxXQUFXLENBQUMsQ0FBQzs7b0JBRS9ELE1BQU0sSUFBSSwwREFBaUQsQ0FBQyxXQUFXLEVBQUUsV0FBVyxDQUFDLENBQUM7YUFDN0Y7WUFFRCxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUM1QixDQUFDLENBQUMsQ0FBQztJQUVYLENBQUM7SUFFTSxXQUFXO1FBQ2QsT0FBTyxJQUFJLENBQUMsc0JBQXNCLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUNsRSxDQUFDO0NBQ0o7QUExQ0Qsb0NBMENDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXhlY3V0ZVNlbGVjdG9yQ29tbWFuZCB9IGZyb20gJy4uLy4uL3Rlc3QtcnVuL2NvbW1hbmRzL29ic2VydmF0aW9uJztcbmltcG9ydCB7IEV4ZWN1dGVTZWxlY3RvckZuIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IE5PREVfVFlQRV9ERVNDUklQVElPTlMgZnJvbSAnLi4vdXRpbHMvbm9kZS10eXBlLWRlc2NyaXB0aW9ucyc7XG5pbXBvcnQge1xuICAgIEFjdGlvblNlbGVjdG9yTWF0Y2hlc1dyb25nTm9kZVR5cGVFcnJvcixcbiAgICBBY3Rpb25BZGRpdGlvbmFsU2VsZWN0b3JNYXRjaGVzV3JvbmdOb2RlVHlwZUVycm9yLFxufSBmcm9tICcuLi8uLi9zaGFyZWQvZXJyb3JzJztcbmltcG9ydCB7IGdldEludmlzaWJsZUVycm9yQ3RvciwgZ2V0Tm90Rm91bmRFcnJvckN0b3IgfSBmcm9tICcuLi9lcnJvcnMvc2VsZWN0b3ItZXJyb3ItY3Rvci1jYWxsYmFjayc7XG4vLyBAdHMtaWdub3JlXG5pbXBvcnQgeyBuYXRpdmVNZXRob2RzLCBQcm9taXNlIH0gZnJvbSAnLi4vLi4vY2xpZW50L2RyaXZlci9kZXBzL2hhbW1lcmhlYWQnO1xuLy8gQHRzLWlnbm9yZVxuaW1wb3J0IHsgZG9tVXRpbHMgfSBmcm9tICcuLi8uLi9jbGllbnQvZHJpdmVyL2RlcHMvdGVzdGNhZmUtY29yZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVsZW1lbnRzUmV0cmlldmVyPFQ+IHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IF9nbG9iYWxTZWxlY3RvclRpbWVvdXQ6IG51bWJlcjtcbiAgICBwcml2YXRlIHJlYWRvbmx5IF9lbnN1cmVFbGVtZW50c1N0YXJ0VGltZTogbnVtYmVyO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgX2V4ZWN1dGVTZWxlY3RvckZuOiBFeGVjdXRlU2VsZWN0b3JGbjxUPjtcbiAgICBwcml2YXRlIHJlYWRvbmx5IF9lbGVtZW50czogVFtdO1xuICAgIHByaXZhdGUgX2Vuc3VyZUVsZW1lbnRzUHJvbWlzZTogUHJvbWlzZTx2b2lkPjtcblxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvciAoZ2xvYmFsU2VsZWN0b3JUaW1lb3V0OiBudW1iZXIsIGV4ZWN1dGVTZWxlY3RvckZuOiBFeGVjdXRlU2VsZWN0b3JGbjxUPikge1xuICAgICAgICB0aGlzLl9nbG9iYWxTZWxlY3RvclRpbWVvdXQgICA9IGdsb2JhbFNlbGVjdG9yVGltZW91dDtcbiAgICAgICAgdGhpcy5fZW5zdXJlRWxlbWVudHNTdGFydFRpbWUgPSBuYXRpdmVNZXRob2RzLmRhdGVOb3coKTtcbiAgICAgICAgdGhpcy5fZW5zdXJlRWxlbWVudHNQcm9taXNlICAgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgdGhpcy5fZXhlY3V0ZVNlbGVjdG9yRm4gICAgICAgPSBleGVjdXRlU2VsZWN0b3JGbjtcbiAgICAgICAgdGhpcy5fZWxlbWVudHMgICAgICAgICAgICAgICAgPSBbXTtcbiAgICB9XG5cbiAgICBwdWJsaWMgcHVzaCAoc2VsZWN0b3I6IEV4ZWN1dGVTZWxlY3RvckNvbW1hbmQsIGVsZW1lbnROYW1lPzogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2Vuc3VyZUVsZW1lbnRzUHJvbWlzZSA9IHRoaXMuX2Vuc3VyZUVsZW1lbnRzUHJvbWlzZVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9leGVjdXRlU2VsZWN0b3JGbihzZWxlY3Rvciwge1xuICAgICAgICAgICAgICAgICAgICBpbnZpc2libGU6IGdldEludmlzaWJsZUVycm9yQ3RvcihlbGVtZW50TmFtZSksXG4gICAgICAgICAgICAgICAgICAgIG5vdEZvdW5kOiAgZ2V0Tm90Rm91bmRFcnJvckN0b3IoZWxlbWVudE5hbWUpLFxuICAgICAgICAgICAgICAgIH0sIHRoaXMuX2Vuc3VyZUVsZW1lbnRzU3RhcnRUaW1lKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigoZWw6IFQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWRvbVV0aWxzLmlzRG9tRWxlbWVudChlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZVR5cGUgICAgPSAoZWwgYXMgdW5rbm93biBhcyB7IG5vZGVUeXBlOiBudW1iZXIgfSkubm9kZVR5cGU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVUeXBlU3RyID0gTk9ERV9UWVBFX0RFU0NSSVBUSU9OU1tub2RlVHlwZV07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlbGVtZW50TmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBBY3Rpb25TZWxlY3Rvck1hdGNoZXNXcm9uZ05vZGVUeXBlRXJyb3Iobm9kZVR5cGVTdHIpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQWN0aW9uQWRkaXRpb25hbFNlbGVjdG9yTWF0Y2hlc1dyb25nTm9kZVR5cGVFcnJvcihlbGVtZW50TmFtZSwgbm9kZVR5cGVTdHIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRzLnB1c2goZWwpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0RWxlbWVudHMgKCk6IFByb21pc2U8VFtdPiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbnN1cmVFbGVtZW50c1Byb21pc2UudGhlbigoKSA9PiB0aGlzLl9lbGVtZW50cyk7XG4gICAgfVxufVxuIl19